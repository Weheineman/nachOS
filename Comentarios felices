EJERCICIO 1
-- Preguntar como estructurar lindo los test cases.
-- Preguntar sobre cómo no hacer que starveen los writers en RWTest.
Test cases:
	- Ver que muchos archivos puedan leer al mismo tiempo.
	- Ver que archivos que lean y escriban funcionen bien entre ellos.
  - Ver que varios threads que accedan en simultaneo a distintos archivos no se molesten.
	Posiblemente para tests anteriores haya que meter random breaks y algunos controlados como ya hemos hecho. A lo sumo chusmear los test cases de thread_test
	- Interrumpir lecturas y escrituras?
	- Casos que involucren eliminar un archivo:
		- Eliminar uno no abierto.
		- Eliminar uno abierto, modificarlo mientras esté en pendingQueue, luego todos salen.
		- Eliminar uno abierto, tratar de abrirlo y que no nos deje, salir y que se cierre.
		- Eliminarlo múltiples veces.


EJERCICIO 5
Vamos a tener que implementarnos vectors propios. Vamos a necesitar eso para la tabla de Directory, que ahora tiene que ser extensible (Gracias C++ por no tener un resize de new y delete).
La estructura de directorios para soporte de concurrencia parece bastante similar a los archivos abiertos:
	- Cada thread aporta un incremento al contador de un directorio
	- Para realizar operaciones de directorios (crear, eliminar, moverse) se necesita un acceso a la lista de directorios.
	- Hay algunos caveats a las operaciones. Por ejemplo: Para eliminar un directorio no basta con que ese directorio no esté abierto, sino también no tiene que estar abierto ninguno de sus hijos.
Cosas a implementar como mínimo: mkdir, rmdir, cd. Para cada directorio vamos a necesitar saber su daddy para poder movernos para arriba. Probablemente varias operaciones de OpenFile ahora necesiten saber la posición en el árbol de directorios :)


Roadmap

 - Thread debe conocer su path y tener una interfaz para consultar y modificarlo.

 - exception.cc tiene la implementacion de las syscalls. Hay que modificar dichas
 implementaciones para que no solo pasen el nombre del archivo como argumento a
 las llamadas fileSys, sino que la ruta completa (strconcat?).

 - fileSys ahora tiene una interfaz similar a freeMap pero con nuestra nueva
 estructura cool de directorios (DirectoryTree?).
   Ademas hay que cambiar todas las creaciones y llamadas de Directory por
nuestra interfaz que provee a DirectoryTree y metodos de DirectoryTree.

  - Hay que hacer una estructura DirectoryTree que reemplace completamente a
Directory. No hay problema porque Directory solo se llama desde fileSys.
    Tiene que proveer create, find, delete, list. Y concurrencia.
	Seria bueno modificar directory_entry para que almacene informacion como
si la entrada es un archivo o un directorio
	Seria bueno dejar de trabajar con arrays estaticos en raw_directory porque
no se prestan como estructura de datos extensible. Lista enlazada?


  - Tener en cuenta que no se rompa freeMap, ojo con los deadlocks, ver ojo arriba.
Seguramente sea bueno garantizar que al modificar directory siempre se tenga
acceso a freeMap previamente y modificar writeAt para que no pida el freeMap en
este caso.


DING DING R**** ALERT DING DING
Creamos DirectoryLockManager porque tener locks locales en RAM no arregla
concurrencia en directorios. Es una estructura global que mantiene pares
(sector, RW) e implementa Acquire y Release por sector. El sector es el
sector en disco del fileheader del directorio.

	- Cambiar ReaderWriter en Directory por DirectoryLockManager.
