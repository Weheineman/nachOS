HAY QUE COMENTAR CODIGO DEL EJERCICIO 1 :^)

Update 04/11
Hay que preguntar qué hacemos con el parsing de direcciones en el sistema de archivos para las syscalls.
Por ahora, nuestra suposicion es: - Si el filename empieza con una barra (el root) entonces suponemos que el pathing es global.
                                  - Si el filename empieza con ./ , ../ o directamente un nombre, suponemos que es relativo a la posición del Thread.
Con respecto a la interfaz de Threads: Tendría que tener alguna especie de getPath y setPath.
Se me ocurre handlear de dos formas distintas: - Podemos tener una especie de "lista" que sea un path y con eso nos las arreglamos para manejar bastante lindo el recorrer el árbol y hacer cosas como ../
                                               - Podemos armarnos varios tokenizers y manejar el path como un string, laburando todo directamente a nivel de char y listo.
                                               DING DING DING WE HAVE A WINNER: Listas doblemente enlazadas and fuck it
Podemos tener una clase Path que nos permita hacer todas esas cositas bellas que queremos hacer.
Métodos: FilePath(...)
         Destructor()
         FromString(char *pathString) ?
         ToString() ?
         RemoveFirstSlash() -> Ver si esto va a ser necesario con la implementacion nueva
         IsBottomLevel() -> Dice si estás en el ultimo elemento del path
         IsEmpty() ?
         SplitCurrentLevel() -> Separa un path que no está en BottomLevel. Devuelve el string del nivel más cercano y cambia el path para que avance
         Merge(...) -> Toma un string o un path y (devuelve un path?) con el mergeo de ambos. Esto va a ser útil para la implementación de las syscalls. 
         
Decisiones de código:
 - FilePath asume que el string con el que lo construyen arranca con /.
 - Preguntarle a los chicos todo el mambo de las barras al final, al principio, si van, si no, bla bla bla.



Update 09/10
Reader/Writer ya en el Makefile.
Cambiamos Reader/Writer ft. Grinblat.
Cambiamos el Reader/Writer de la OpenFileList por un Lock.
Agregamos la referencia al FileLock en los OpenFile. Por ahora permitimos que haya fileLock nulo, revisar esto.
    Opciones para manejar Bitmap y Directory como archivos:
        - Tenerlos como archivos normales: tienen su entry en la lista y se manejan como un archivo normal. El problema con esto es que probablemente haya algún tema de tomar dos veces el Lock (por ejemplo, si un thread quiere crear un archivo nuevo o algo así)
ESTA -> - Tienen tratamiento especial dentro de OpenFile cuando al pasarle name y rw como nullptr
        - Que el SO los abra cuando inicializa y solamente él tenga acceso. Esta opción probablemente involucre toquetear mucho código.
Existe la posibilidad que no hayamos comentado una mierda. Woops. Update 16/10: No me digas.
- Revisar que el file system interactúe con el Bitmap a partir de los métodos que definimos.

UPDATE 10/10
- Arreglamos el comportamiento de los OpenFile.
- Resolvimos el problema de ReadAt/WriteAt porque somos muy inteligentes.
- Creamos el método privado DeleteFromDisk del FileSystem, para eso hicimos que sea bestu con la OpenFileList.
- CUANDO FUNCIONE, PARA OPTIMIZAR: AcquireFreeMap hace una copia del freeMap. Si el freeMap lo gestionamos nosotros en filesystem, por que no mantener un puntero y devolver solo el puntero (en vez de alocar memoria cada vez)

NOTAS PARA TUTTURU DEL FUTURO
OJO OJO OJO OJO!!! directory->add() NOOO tiene que tomar locks del freeMap. Mirar fileSystem -> create() si no me crees.
Pasa lo mismo con directory->remove() en DeleteFromDisk()
OJO (de nuevo). WriteAt pide el freeMap. Esto NO genera una dependencia circular con freeMap, porque freeMap nunca se extiende.
Si Directory se extendiera en algun momento, SI habria una dependencia circular. OJO.


PRACTICA 5

COMENTARIOS EJERCICIO 1
A nivel de FileSystem, hay una tabla de archivos abierto. A cada archivo abierto le corresponde un lock.
Cada OpenFile está asociado a un archivo, y puede consultar el lock correspondiente. Necesita tener el lock para hacer ciertas operaciones.
Desde el nivel de FS también pueden checkearse las peticiones de delete and stuff.
Problemón: Bitmap y Directory. Alguna operación utiliza el bitmap para sólo lectura? - Si no, usamos un lock en la interfaz de FileSystem y listo.
                                                                                     - Si sí, habrá que implementar modos de apertura.

EJERCICIO 5
Pedir explicación de enunciados. No entendemos si los comandos que tenemos que implementar son a nivel de thread o QUÉ.
Confirmado, son a nivel de Thread >:(
